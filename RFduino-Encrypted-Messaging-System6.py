#	An encrypted messaging for the Raspberry Pi / computer (Depending on the serial driver) that uses FTDI and RFDuino.
#   The encryption code is randomized every time the program is run. Neither users know the encryption key for added security.
#	Written by Johnny Dunn
#	Sender = RFduino device

import threading
from threading import Thread
from time import sleep
from queue import Queue
import os
import math
import random
import time
import sys
import string, socket, select
#import RPI.GPIO as GPIO
import serial
import getpass 
serdata=""
#serQ=Queue(20) 
global comport          #The USB port that the RFduino is connected to. 
                        #Will be 'COM4', 'COM5', etc on Windows, and ttyam0 on the Raspberry pi. 
global ser   
sendingMessage = False         #Is the user sending a message?       
receivingMessage = False       #Is the user receiving a message?
changeMode = False      #When changeMode is true, the program goes back to sending / receiving options
broadcastingKey = False  #Is the key being broadcast by the sender?

global randomKeyGenerated  #Boolean checking to see if a random key has already been generated for encryptor    #Input asking if user wants to keep sending messages
global enterMessageToEncode
global broadcastingKeyPass
global messageThatIsEncrypted1
global enterMessageToDecode1
global randomKey      #Encryption / decoder key that is randomized every time program begins. Neither users will ever see the key, so it is more secure. 
global translated      

global firstTimeRunning         #The program is running for the first time, and instructions are printed out
global serialOn                 #An RFduino is connected and being used
global keyPass                  #The 4-digit pass key entered by the sender that should be entered and matched by the receiver
global keyMatchFound            #The pass key has been found and matched by the host and device
global keyPassRead              #The pass key that is being read by the device to see if there is a match
global keyPassEntered         #The pass key has already been generated or not?
changeMode = False
broadcastingKey = False
broadcastingKeyPass = False
serInt = 0
randomKeyGenerated = False    #Random cipher key not yet generated
keyPassEntered = False        #Pass key not yet entered
firstTimeRunning = True
keyPassFound = False
serialOn = False

def cls():
    os.system('cls' if os.name=='nt' else 'clear')

def beginSetup ():
    global keyPass
    global firstTimeRunning
    global ser
    global comport
    global broadcastingKeyPass
    global keyMatchFound
    global keyPassRead
    if (firstTimeRunning == True):
        print("\n           Encrypted Messaging Application for RFduinos")
        print("\n      The RFduino sketches should already be loaded with the correct code.")
        print("\n      A randomized cypher key will be generated by the 'DEVICE', or sender,")
        print("\n      and the 'HOST', or receiver, will secure that cypher key if the right passkey")
        print("\n      has been entered by both users using the Messenger. Neither users will know the")
        print("\n      one-time, randomized cypher in Messenger. The Encryptor / Decryptor generates")
        print("\n      a cypher printed out to the user so that specific messages may be secured and")
        print("\n      decoded with a known password. The Messenger is for chatting live only, as the")
        print("\n      cypher is not stored but randomized every time. Note: The sender must start the")
        print("\n      program first and enter a password that the receiver must already know to begin")
        print("\n      the messenger.")
        inputPort = input("\n    Enter the exact USB port that the RFduino is connected to, e.g. COM7. \n\n    If just using the encryptor / decoder and not RFduinos, type 'none'\n\n")
        if (inputPort == "none") | (inputPort == "None"):
            serialOn = False
        else: 
            print("\n    If the wrong port is entered, the program will crash.") 
            sleep(1)
            comport = inputPort
            serialOn = True
            ser = serial.Serial(comport, 9600)
            print("\n    Port has been selected.")
        #ser = serial.Serial(comport, 9600)   
        firstTimeRunning = False
        if (broadcastingKeyPass == True): 
            #ser.write(keyPass.encode())
            print("\n    Pass key is now being broadcast and seeking a match.")
            keyMatchFound  = True
    print("\n----------------------------------------------------------------------------------------")
    inputActivate = input("    MENU: Type 'Encryption' or 'Decryption' or 'Messenger' or 'Quit'\n\n")
    if (inputActivate == 'Encryption') | (inputActivate == 'encryption'):
        beginEncryptor()
    elif (inputActivate == 'Decryption') | (inputActivate == 'decryption'):
        beginDecryptor()
    elif (inputActivate == 'Messenger') | (inputActivate == 'messenger'):
        userSetup() 
    elif (inputActivate == 'Quit') | (inputActivate =='quit'):
        print("\nExiting..\n")
        exit()
    else:
        print("\nCommand not understood!\n\n")    
        beginSetup()

def beginEncryptor() :
    global messageThatIsEncrypted1
    global translated
    if (randomKeyGenerated == False):
        generateCipherKey()
    startEncryption()
    sleep(2.5)
    print("Clearing screen and memory..")
    sleep(.75)
    cls()
    print("Your encoded message is: ")
    print(translated)
    inputActivate = input("\nEncode another message? (Yes / No)\n\n")
    if (inputActivate == 'Yes') | (inputActivate == 'yes'):
        sleep(2.5)
        print("Clearing screen and memory..\n")
        sleep(.75)
        cls()
        #translated = ""
        beginEncryptor()
    elif (inputActivate == 'No') | (inputActivate == 'no'):
        inputActivate = input('\nWipe screen and memory?\n\n')
        if (inputActivate == 'Yes') | (inputActivate == 'yes'):
            sleep(.25)
            cls()
            #translated = ""
            beginSetup()
        elif (inputActivate == 'No') | (inputActivate == 'no'):
            beginSetup()
        else:
            print("\nCommand not understood!\n")
            startEncryption()

def startEncryption() :
    global enterMessageToEncode
    global message
    global messageThatIsEncrypted1
    global translated
    translated = ''
    charCode1 = ""
    messageThatIsEncrypted1 = ""
    enterMessageToEncode = input("Enter the message to be encoded: \n\n")
    for symbol in enterMessageToEncode:
        if symbol.isalpha():
            charCode = ord(symbol)
            randomKey1 = randomKey
            randomKey1 = int(randomKey * randomKey / 2)
            randomKey2 = int(randomKey1 / randomKey)
            randomKey3 = int(randomKey2) - abs(int(randomKey)) - abs(int(randomKey))
            #randomKey3 -= int(abs(randomKey * 5))
            randomKey1 = randomKey3
            charCode += randomKey1           
            if symbol.isupper():
                if charCode > ord('Z'):
                    charCode -= 26
                elif charCode < ord('A'):
                    charCode += 26    
            elif symbol.islower():
                if charCode > ord('z'):
                    charCode -= 26
                elif charCode < ord('a'):
                    charCode += 26 
            translated += chr(charCode)
        else:
            translated += symbol
    return translated

def generateCipherKey() :
    global randomKeyGenerated
    global randomKey
    if (randomKeyGenerated == False):
        randomKey = random.randrange(-9,9)     #Cipher key is generated that adds or subtracts randomized value to encryption
        checkRandomKey()
        print("\nYour randomly generated ciper is: " + str(randomKey)+"\n")
    print("Use this cipher for decrypting messages encoded with this key.\n")
    randomKeyGenerated = True
    return randomKey

def checkRandomKey() :
    global randomKey
    global randomKeyGenerated
    if (randomKey == 0):
        randomKeyGenerated = False
        generateCipherKey()
    else:
        randomKeyGenerated == True
        return randomKey

def beginDecryptor() :
    global enterMessageToDecode1
    global translated
    startDecryption()
    print("\nDecoded message: \n")
    print(translated)
    inputActivate = input('\nDecode another message? (Yes / No) \n\n' )
    if (inputActivate == 'Yes') | (inputActivate == 'yes'):
        beginDecryptor()
    elif (inputActivate == 'No') | (inputActivate == 'no'):
        beginSetup()

def startDecryption() :
    global enterMessageToDecode1
    global randomKey
    global messageBeenDecoded
    global translated
    global symbol1
    symbol1 = ""
    randomKey = int(input("\nEnter the cipher code that was randomly generated by the encryptor: \n\n"))
    enterMessageToDecode = input("\nEnter the message to be decrypted: \n\n")
    enterMessageToDecode1 = enterMessageToDecode
    enterMessageToDecode2 = ""
    letterCode1 = ""
    messageToDecode = ""
    translated = ""
    for symbol in enterMessageToDecode:
            charCode = ord(symbol)
            randomKey1 = randomKey
            randomKey1 = int(randomKey * randomKey / 2)
            randomKey2 = int(randomKey1 / randomKey)
            randomKey3 = int(randomKey2) - abs(int(randomKey)) - abs(int(randomKey))
            #randomKey3 -= int(abs(randomKey * 5))
            randomKey1 = randomKey3
            charCode -= randomKey1    
            if charCode > ord('z'):
                charCode -= 26
            if symbol.isupper():
                if charCode > ord('Z'):
                    charCode -= 26
                elif charCode < ord('A'):
                    charCode += 26    
            elif symbol.islower():
                if charCode > ord('z'):
                    charCode -= 26
                elif charCode < ord('a'):
                    charCode += 26 
                translated += chr(charCode)
            else:
                translated += symbol
    return translated

def userSetup (): 
    global randomKey
    inputActivate = input('\nSending or receiving message(s)? (Send / Receive) \n\n' )
    if (inputActivate == 'Send') | (inputActivate == 'send'):       #User is the sender / device
        sendingMessage = True
        receivingMessage = False
        sendMessage()
    elif (inputActivate == 'Receive') | (inputActivate == 'receive'):  #User is the receiver
        receivingMessage = True
        sendingMessage = False
        broadcastingKey = True
        receiveMessage()
    else:
        changeMode = True
        print("\nCommand not understood!\n\n")
        userSetup()

def startInterface ():                      #The terminal-based interface for the program. Also `
    global firstTimeRunning
    global changeMode
    sendingMessage = False
    receivingMessage = False
    inputActivate = ""
    if (firstTimeRunning == True):          #First time running program?
        #Begin user setup
	    beginSetup()
    #Begins new message transmission
    if (firstTimeRunning == False) & (changeMode == True):       #Already started running program 
       inputActivate = input('\nSending or receiving message(s)? (Send / Receive) \n\n')
       changeMode = False
    elif (firstTimeRunning == False) & (inputActivate == 'Send'):
        sendingMessage = True
        receivingMessage = False
        print("\nNow sending encrypted messages.\n")
    elif (firstTimeRunning ==  False) & (inputActivate == 'Receive'): 
        sendingMessage = False
        receivingMessage = True
        print("\nNow decoding received messages.\n")
    if (sendingMessage == True):
	    sendMessage()
	    receivingMessage = False 
    elif (receivingMessage == True):
        receiveMessage()
        sendingMessage = False

def findKeyPass():
    global keyPass
    global keyPassRead
    global keyPassFound
    global keyPassFoundString
    global broadcastingKeyPass
    global ser
    global keyPassEntered
    if (keyPassFound == False) & (keyPassEntered == False):
        keyPassRead = ""
        keyPass = getpass.getpass(prompt="\n    Enter a 4-digit pass key to find device: \n\n")
        print("\n    Your partner must know and input this same exact pass key as he starts the program too.")
        sleep(1.0)
        keyPassEntered = True
    if (keyPassFound == False):
        broadcastingKeyPass = True
        if (broadcastingKeyPass == True):    
            ser.write(str(keyPass).encode()) 
            print("\n    Device is now broadcasting pass key for partner to receive.")
            print("\n    Device is now reading for a matching pass key.")
           # keyPassRead = ser.readline()
            if (keyPassRead == keyPass):
                keyPassFound = True
                broadcastingKeyPass = False
                print("\n    The pass key has found a match.")
            else: 
                sleep(.5)
                inputActivate = input("\n    Matching pass key has not been found. Keep searching? (Yes / No) \n\n")
                if (inputActivate == 'Yes') | (inputActivate == 'yes'):
                    keyPassFound = False
                    broadcastingKeyPass = True
                    findKeyPass()
                elif (inputActivate == 'No') | (inputActivate == 'no'):
                    keyPassFound = False
                    broadcastingKeyPass = True
                    beginSetup()
                else: 
                    print("\n    Command not understood!")
                    keyPassFound = False
                    broadcastingKeyPass = True
                    beginSetup()

def sendMessage ():
    global ser
    while True:
        findKeyPass()
    userMessage = input("\nEnter the message to encode: \n\n")			#Unencrypted message that the sender writes
    messageToEncrypt = userMessage
    print("\nMessage encoded: \n")
    for symbol in messageToEncrypt:
        if symbol.isalpha():
            charCode = ord(symbol)
            randomKey1 = randomKey
            randomKey1 = int(randomKey * randomKey / 2)
            randomKey2 = int(randomKey1 / (randomKey / 3))
            randomKey3 = int(randomKey2) - abs(int(randomKey)) - abs(int(randomKey))
            randomKey3 -= int(abs(randomKey * 1.5))
            randomKey1 = randomKey3
            charCode += randomKey1           
            if symbol.isupper():
                if charCode > ord('Z'):
                    charCode -= 26
                elif charCode < ord('A'):
                    charCode += 26    
            elif symbol.islower():
                if charCode > ord('z'):
                    charCode -= 26
                elif charCode < ord('a'):
                    charCode += 26 
            translated += chr(charCode)
        else:
            translated += symbol
    print("\n    Encrypted message: ")
    print(translated)
    ser.write(translated).encode()
    sleep(.25)
    print("\n    Encrypted message sent to partner.")
    successfulMessage = input("\nContinue sending messages? (Yes / No): \n\n")   #After sending message, ask if user wants to keep sending
    if (successfulMessage == "Yes") & (successfulMessage == "yes"):
        changeMode = False
        startInterface() 
        #Message + chr(ord(receivedMessage.split[ch] - randomKey))   #Get the c+10orresponding letter to Unicode number
        #codeMsg = eval(splitMsg)    #Converts digits to a number                           #and further decodes it with randomized key generated.
        #chars.append(chr(ord()code))     #Accumulates characters
        #decodedMessage = "".join(chars)           #Message is formed from characters
    print("\nDecoded Message: ", decodedMessage + "\n")       #Prints out the decoded message
    seenMessage = input("\nContinue receiving messages? (Yes / No): \n\n")    #Asks if user wants to keep receiving messages or switch
    if (seenMessage == "Yes") & (seenMessage == "yes"):
        changeMode = False
        startInterface()                     #If yes, go back to main interface and skip setup screen
    elif (seenMessage == "No") & (seenMessage == "no"):
        changeMode = True
        startInterface()                     #If no, go back to main interface and set up sending / receiving
    else: 
        print("\nCommand not understood!\n")
        changeMode = False
        startInterface()

def receiveMessage ():
    global ser
    while True:
        findKeyPass()
       # if serInt > 0:
        #    serInt = randomKey
         #   receivedMessage = ser.read() 
    #receivedMessage = ser.readline() #Reads the incoming, wirelessly transmitted encrypted message from other device
    while True:
        if (keyPassFound == True):
            keyPassRead = serial.readline()
            print ("\nReceived encrypted message: ")
            print ("keyPassRead")
        sleep(.5)
        print("\nDecoding..")
    #chars = []
    #Loop through the message and print out the decoded values
    #for ch in receivedMessage:    #Messages are separated by spaces by default to distinguish words
     #   decodedMessage = decodedMessage + chr(ord(receivedMessage.split()[ch] - randomKey))   #Get the corresponding letter to Unicode number
        #codeMsg = eval(splitMsg)    #Converts digits to a number                           #and further decodes it with randomized key generated.
        #chars.append(chr(ord()code))     #Accumulates characters
    #decodedMessage = "".join(chars)           #Message is formed from characters
    for symbol in enterMessageToDecode:
            charCode = ord(symbol)
            randomKey1 = randomKey
            randomKey1 = int(randomKey * randomKey / 2)
            randomKey2 = int(randomKey1 / (randomKey / 3))
            randomKey3 = int(randomKey2) - abs(int(randomKey)) - abs(int(randomKey))
            randomKey3 -= int(abs(randomKey * 1.5))
            randomKey1 = randomKey3
            charCode -= randomKey1    
            if charCode > ord('z'):
                charCode -= 26
            if symbol.isupper():
                if charCode > ord('Z'):
                    charCode -= 26
                elif charCode < ord('A'):
                    charCode += 26    
            elif symbol.islower():
                if charCode > ord('z'):
                    charCode -= 26
                elif charCode < ord('a'):
                    charCode += 26 
                translated += chr(charCode)
            else:
                translated += symbol
    print("\n    Decrypted message: ")
    print(translated)
    seenMessage = input("\nContinue receiving messages? (Yes / No): \n\n")    #Asks if user wants to keep receiving messages or switch
    if (seenMessage == "Yes") & (seenMessage == "yes"):
        changeMode = False
        startInterface()                     #If yes, go back to main interface and skip setup screen
    elif (seenMessage == "No") & (seenMessage == "no"):
        changeMode = True
        startInterface()                     #If no, go back to main interface and set up sending / receiving
    else: 
        print("\nCommand not understood!\n\n")
        changeMode = False
        startInterface()

def main ():
	startInterface()                         #Begins Terminal interface for encryption program
	
if __name__ == "__main__":
  main()