#	An encrypted messaging for the Raspberry Pi / computer (Depending on the serial driver) that uses FTDI and RFDuino.
#   The encryption code is randomized every time the program is run. Neither users know the encryption key for added security.
#	Written by Johnny Dunn and Gentry Demchak
#	Sender = RFduino device

import threading
from threading import Thread
from time import sleep
from queue import Queue
#from queue import 
import os
import math
import random
import time
import sys
import string, socket, select
#import RPI.GPIO as GPIO
import serial
import getpass 
serdata=""
serQ=Queue(20) 
comport = 'COM7'
ser = serial.Serial(comport, 9600)   #Reads incoming serial data. Change the directory and
sendingMessage = False                 #of this driver to switch between platforms (Pi and computer).
receivingMessage = False
changeMode = False      #When changeMode is true, the program goes back to sending / receiving options
broadcastingKey = False  #Is the key being broadcast by the sender?
#keyPass             #String to be filtered out of the messages; for further device security
#inputActivate         #Text comamnd user sends to activate sending / receiving
#encryptedMessage = ""   #Message that the device /sender inputs to be encrypted   
#receivedMessage = ""
global randomKeyGenerated  #Boolean checking to see if a random key has already been generated for encryptor    #Input asking if user wants to keep sending messages
global enterMessageToEncode
#seenMessage             #Input asking if user wants to keep receiving messages
#decodedMessage
#encodedMessage
#encodedMessage1
#messageThatIsEncrypted
#messageThatIsEncrypted1
#enterMessageToDecode1
global messageThatIsEncrypted1
global enterMessageToDecode1
global randomKey      #Encryption / decoder key that is randomized every time program begins. Neither users will ever see the key, so it is more secure. 
global translated
serInt = 0               #Sets serial reading data 
codeNum = 0
#String userMessage				#The message that the device sends to the host
global firstTimeRunning
changeMode = False
broadcastingKey = False
broadcastingKeyPass = False
serInt = 0
randomKeyGenerated = False
firstTimeRunning = True

def cls():
    os.system('cls' if os.name=='nt' else 'clear')

def beginSetup ():
    global firstTimeRunning
    if (firstTimeRunning == True):
        print("\n           Encrypted Messaging Application for RFduinos")
        print("\n      The RFduino sketches should already be loaded with the correct code.")
        print("\n      A randomized cypher key will be generated by the 'DEVICE', or sender,")
        print("\n      and the 'HOST', or receiver, will secure that cypher key if the right passkey")
        print("\n      has been entered by both users using the Messenger. Neither users will know the")
        print("\n      one-time, randomized cypher in Messenger. The Encryptor / Decryptor generates")
        print("\n      a cypher printed out to the user so that specific messages may be secured and")
        print("\n      decoded with a known password. The Messenger is for chatting live only, as the")
        print("\n      cypher is not stored but randomized every time.")
        firstTimeRunning = False
        keyPass = getpass.getpass(prompt='\n    Enter a 1-digit pass key to find device: \n')
        broadcastingKeyPass = True
        print("\n    Your partner must know and input this same exact pass key as he starts the program too.\n")
        if (broadcastingKeyPass == True): 
            ser.write(keyPass.encode())
        #print("Pass key has been stored.")
    print("----------------------------------------------------------------------------------------")
    inputActivate = input("    MENU: Type 'Encryption' or 'Decryption' or 'Messenger' or 'Quit'\n\n")
    print("----------------------------------------------------------------------------------------")
    if (inputActivate == 'Encryption') | (inputActivate == 'encryption'):
        beginEncryptor()
    elif (inputActivate == 'Decryption') | (inputActivate == 'Decryption'):
        beginDecryptor()
    elif (inputActivate == 'Messenger') | (inputActivate == 'messenger'):
        userSetup() 
    elif (inputActivate == 'Quit') | (inputActivate =='quit'):
        print("\nExiting..\n")
        exit()
    else:
        print("\nCommand not understood!\n\n")    
        beginSetup()

def beginEncryptor() :
    global messageThatIsEncrypted1
    global translated
    generateCipherKey()
    startEncryption()
    sleep(2.5)
    print("Clearing screen and memory..")
    sleep(.75)
    cls()
    print("Your encoded message is: ")
    print(translated + "\n")
    inputActivate = input('\nWould you like to encode another message? (Yes / No)\n\n')
    if (inputActivate == 'Yes') | (inputActivate == 'yes'):
        sleep(2.5)
        print("Clearing screen and memory..\n")
        sleep(.75)
        cls()
        #translated = ""
        beginEncryptor()
    elif (inputActivate == 'No') | (inputActivate == 'no'):
        inputActivate = input('\nWipe screen and memory?\n\n')
        if (inputActivate == 'Yes') | (inputActivate == 'yes'):
            sleep(.25)
            cls()
            #translated = ""
            beginSetup()
        elif (inputActivate == 'No') | (inputActivate == 'no'):
            beginSetup()
        else:
            print("\nCommand not understood!\n\n")
            startEncryption()

def startEncryption() :
    global enterMessageToEncode
    global message
    global messageThatIsEncrypted1
    global translated
    translated = ''
    charCode1 = ""
    messageThatIsEncrypted1 = ""
    enterMessageToEncode = input("Enter the message to be encoded: \n\n")
    for symbol in enterMessageToEncode:
        if symbol.isalpha():
            charCode = ord(symbol)
            charCode += randomKey           # charCode *= int(randomKey * 2)
           # charCode *= int(randomKey * 2)
            #charCode -= int(randomKey * 2)
            #if charCode > ord('z'):
                #charCode -= 26
            #charCode1 = charCode1 + str(charCode)
            if symbol.isupper():
                if charCode > ord('Z'):
                    charCode -= 26
                elif charCode < ord('A'):
                    charCode += 26    
            elif symbol.islower():
                if charCode > ord('z'):
                    charCode -= 26
                elif charCode < ord('a'):
                    charCode += 26 
            translated += chr(charCode)
        else:
            translated += symbol
    return translated

       # else: 
           # charCode1 = charCode1 + symbol    
    #messageThatIsEncrypted1 = charCode1
    #print("Encrypted message: " + messageThatIsEncrypted1)
        #numCode = ord(symbol) + randomKey
        #messageThatIsEncrypted1 = chr(numCode + randomKey)
        #numCode1 = chr(numCode)
        #messageThatIsEncrypted1 += str(numCode)
    #print(messageThatIsEncrypted1)
        #messageThatIsEncrypted1 += randomKey
        #messageThatIsEncrypted = str(messageThatIsEncrypted1) + messageThatIsEncrypted
    #return messageThatIsEncrypted1


def generateCipherKey() :
    global randomKeyGenerated
    global randomKey
    if (randomKeyGenerated == False):
        randomKey = random.randrange(-9,9)     #Cipher key is generated that adds or subtracts randomized value to encryption
        print("\nYour randomly generated ciper is: " + str(randomKey)+"\n")
        print("Use this cipher for decrypting messages encoded with this key.\n")
        randomKeyGenerated = True
    return randomKey


def beginDecryptor() :
    global enterMessageToDecode1
    global translated
    startDecryption()
    print("\nDecoded message: \n")
    print(translated + "\n")
    inputActivate = input('\nDecode another message? (Yes / No) \n\n' )
    if (inputActivate == 'Yes') | (inputActivate == 'yes'):
        beginDecryptor()
    elif (inputActivate == 'No') | (inputActivate == 'no'):
        beginSetup()

def startDecryption() :
    global enterMessageToDecode1
    global randomKey
    global messageBeenDecoded
    global translated
    global symbol1
    symbol1 = ""
    randomKey = int(input("\nEnter the cipher code that was randomly generated by the encryptor: \n\n"))
    enterMessageToDecode = input("\nEnter the message to be decrypted: \n\n")
    enterMessageToDecode1 = enterMessageToDecode
    enterMessageToDecode2 = ""
    letterCode1 = ""
    messageToDecode = ""
    translated = ""

     #enterMessageToEncode1 = enterMessageToEncode
   # for ch in enterMessageToDecode1:    #Messages are separated by spaces by default to distinguish words
    #messageBeenDecoded1 = chr(ord(enterMessageToDecode.split()[ch]))   #Get the corresponding letter to Unicode number
        #messageBeenDecoded += chr(codeNum)
        #ch1 = int(ch + randomKey)
        #if ch in string.ascii_letters:
        #upper case start of alphabet, to loop back to Z
            #if ord(ch) + int(randomKey) < ord("A")  and ord(ch) >= ord("A"):
                #new_ord = ord(ch) - int(randomKey) + 26
                #lower case end of alphabet
            #elif ord(ch) - int(randomKey) < ord("a") and ord(ch) >= ord("a"):
                #new_ord = ord(ch) - int(randomKey) + 26
            #else:
              #  new_ord = ord(ch) + int(randomKey)
    #other characters will remain unchanged
        #else:
         #   new_ord = ord(ch)
    #new_chr = chr(new_ord)
    #for ch in range(len(enterMessageToDecode1)):    #Messages are separated by spaces by default to distinguish words
     #   ch1 = int(ch) - randomKey
        #print(ch1)
        #enterMessageToDecode1[ch] = str(enterMessageToDecode1[ch])
      #  letterCode = chr(ch1)
       # print ("Letter Code :" , str(letterCode))
        #if letterCode > ord('z'):
                #letterCode -= 26
        #letterCode1 = letterCode1 + letterCode
        #print(enterMessageToDecode2)
            #messageBeenDecoded += new_ord
    #else: 
     #   letterCode1 = letterCode1 + ch
      #  enterMessageToDecode2 = enterMessageToDecode2 + letterCode1
    #letterCode1 = messageToDecode
    #print("Decoded message: ")
    #print(messageToDecode)

        #letterCode = int(ch)
        #letterCode1 = letterCode + int(randomKey)
        #letterCode = chr(ch)
        #letterCode2 = chr(letterCode1)
        #messageBeenDecoded += letterCode2
        #numCode += randomKey
        #messageBeenDecoded += numCode
       # codeNum = eval(ch)
        #chr(codeNum)
    #return messageBeenDecoded
    #codeMsg = eval(splitMsg)    #Converts digits to a number                           #and further decodes it with randomized key generated.
    #chars.append(chr(ord()code))     #Accumulates characters
    #decodedMessage = "".join(chars)           #Message is formed from characters

    for symbol in enterMessageToDecode:
            #print(symbol)
            #symbol1 = int(symbol)
            #symbol1 = int(str(symbol))
            #charCode1 = charCode
            #print(symbol1)
            charCode = ord(symbol)
            #charCode -= randomKey
            #charCode /= int(randomKey * 2)
            #charCode -= int(randomKey * 2)


            charCode -= randomKey           # charCode *= int(randomKey * 2)
           # charCode -= int(randomKey * 2)

            if charCode > ord('z'):
                charCode -= 26
                 #charCode1 = charCode1 + str(charCode)
            if symbol.isupper():
                if charCode > ord('Z'):
                    charCode -= 26
                elif charCode < ord('A'):
                    charCode += 26    
            elif symbol.islower():
                if charCode > ord('z'):
                    charCode -= 26
                elif charCode < ord('a'):
                    charCode += 26 
                translated += chr(charCode)
            else:
                translated += symbol
    return translated


def userSetup (): 
    global randomKey
    inputActivate = input('\nSending or receiving message(s)? (Send / Receive) \n\n' )
    if (inputActivate == 'Send'):       #User is the sender / device
        sendingMessage = True
        receivingMessage = False
        generateCipherKey2()
        print("\nRandomized, one-time key has been generated.\n")
        broadcastingKey = True         #Turn on key broadcasting
        if (broadcastingKey == True):    
            print("\n    Device is now broadcasting key for host to receive.\n")
            #ser.write(randomKey.enocde())
        sendMessage()
    elif (inputActivate == 'Receive'):  #User is the receiver
        receivingMessage = True
        sendingMessage = False
        broadcastingKey = True
        if (broadcastingKey == True):   #Is the sender broadcasting a key?  
            ser.read()                  #If so, read the key
            randomKey = ser.read()      #Get the key as an object
            broadcastingKey = False     #Turn the key broadcasting off once key is gotten by receiver
            print("\nRandomized, one-time key has been found and secured.\n")
        receiveMessage()
    else:
        print("\nCommand not understood!\n\n")
        startInterface()

def generateCipherKey2() :
    global randomKey
    randomKey = random.randrange(-9,9)     #Cipher key is generated that adds or subtracts randomized value to encryption
    return randomKey

def startInterface ():                      #The terminal-based interface for the program. Also `
    global firstTimeRunning
    global changeMode
    sendingMessage = False
    receivingMessage = False
    inputActivate = ""
    if (firstTimeRunning == True):          #First time running program?
        #Begin user setup
	    beginSetup()
    #Begins new message transmission
    if (firstTimeRunning == False & changeMode == True):       #Already started running program 
       inputActivate = input('\nSending or receiving message(s)? (Send / Receive) \n\n')
       changeMode = False
    elif (firstTimeRunning == False) & (inputActivate == 'Send'):
        sendingMessage = True
        receivingMessage = False
        print("\nNow sending encrypted messages.\n")
    elif (firstTimeRunning ==  False) & (inputActivate == 'Receive'): 
        sendingMessage = False
        receivingMessage = True
        print("\nNow decoding received messages.\n")
    if (sendingMessage == True):
	    sendMessage()
	    receivingMessage = False 
    elif (receivingMessage == True):
        receiveMessage()
        sendingMessage = False

def sendMessage ():
    userMessage = input("\nPlease enter the message to encode: \n\n")			#Unencrypted message that the sender writes
    encryptedMessage = userMessage
    print("\nMessage encoded: \n")
    encodedMessage = ""
    #ser.write(userMessage.encode())
    #Loop through the message and print out the coded numerical values
    #for ch in range(0, len(userMessage)):                   #For each character in the sent message
    for ch in encryptedMessage:
        encodedMessage1 = ord(ch)
        encodedMessage1 += randomKey
        encodedMessage = str(encodedMessage1) + encodedMessage
    print(encodedMessage)
    ser.write(encodedMessage.encode())
    successfulMessage = input("\nContinue sending messages? (Yes / No): \n\n")   #After sending message, ask if user wants to keep sending
    if (successfulMessage == "Yes") & (successfulMessage == "yes"):
        changeMode = False
        startInterface() 
        #Message + chr(ord(receivedMessage.split[ch] - randomKey))   #Get the corresponding letter to Unicode number
        #codeMsg = eval(splitMsg)    #Converts digits to a number                           #and further decodes it with randomized key generated.
        #chars.append(chr(ord()code))     #Accumulates characters
    #decodedMessage = "".join(chars)           #Message is formed from characters
    print("\nDecoded Message: ", decodedMessage + "\n")       #Prints out the decoded message
    seenMessage = input("\nContinue receiving messages? (Yes / No): \n\n")    #Asks if user wants to keep receiving messages or switch
    if (seenMessage == "Yes") & (seenMessage == "yes"):
        changeMode = False
        startInterface()                     #If yes, go back to main interface and skip setup screen
    elif (seenMessage == "No") & (seenMessage == "no"):
        changeMode = True
        startInterface()                     #If no, go back to main interface and set up sending / receiving
    else: 
        print("\nCommand not understood!\n\n")
        changeMode = False
        startInterface()

def receiveMessage (serInt, randomKey, receivedMessage, ch, decodedMessage, seenMessage, changeMode):
    while True:
        ser.read(serInt)
        if serInt > 0:
            serInt = randomKey
            receivedMessage = ser.read() 
    #receivedMessage = ser.readline() #Reads the incoming, wirelessly transmitted encrypted message from other device
    print ("\nReceived encrypted message: " + receivedMessage + "\n")
    #chars = []
    #Loop through the message and print out the decoded values
    #for ch in receivedMessage:    #Messages are separated by spaces by default to distinguish words
     #   decodedMessage = decodedMessage + chr(ord(receivedMessage.split()[ch] - randomKey))   #Get the corresponding letter to Unicode number
        #codeMsg = eval(splitMsg)    #Converts digits to a number                           #and further decodes it with randomized key generated.
        #chars.append(chr(ord()code))     #Accumulates characters
    #decodedMessage = "".join(chars)           #Message is formed from characters
    print("\nDecoded Message: ", decodedMessage + "\n")       #Prints out the decoded message
    seenMessage = input("\nContinue receiving messages? (Yes / No): \n\n")    #Asks if user wants to keep receiving messages or switch
    if (seenMessage == "Yes") & (seenMessage == "yes"):
        changeMode = False
        startInterface()                     #If yes, go back to main interface and skip setup screen
    elif (seenMessage == "No") & (seenMessage == "no"):
        changeMode = True
        startInterface()                     #If no, go back to main interface and set up sending / receiving
    else: 
        print("\nCommand not understood!\n\n")
        changeMode = False
        startInterface()

def main ():
	startInterface()                         #Begins Terminal interface for encryption program
	
if __name__ == "__main__":
  main()